using Microsoft.EntityFrameworkCore;
using booking_backend.Data;
using booking_backend.DTOs.Bookings;
using booking_backend.Models;

namespace booking_backend.Services.Bookings;

/// <summary>
/// Service for managing bookings
/// </summary>
public class BookingService : IBookingService
{
    private readonly BookingSystemDbContext _context;

    public BookingService(BookingSystemDbContext context)
    {
        _context = context;
    }

    /// <summary>
    /// Creates a new booking with validation
    /// </summary>
    public async Task<BookingDto> CreateBookingAsync(CreateBookingDto request, CancellationToken cancellationToken = default)
    {
        // Validate time range
        if (request.EndTime <= request.StartTime)
        {
            throw new ArgumentException("EndTime must be after StartTime");
        }

        // Verify service exists and belongs to business
        var service = await _context.Services
            .FirstOrDefaultAsync(s => s.ServiceId == request.ServiceId && s.BusinessId == request.BusinessId, cancellationToken);
        
        if (service == null)
        {
            throw new InvalidOperationException($"Service {request.ServiceId} not found for business {request.BusinessId}");
        }

        // Verify customer exists
        var customer = await _context.Customers
            .FirstOrDefaultAsync(c => c.CustomerId == request.CustomerId, cancellationToken);
        
        if (customer == null)
        {
            throw new InvalidOperationException($"Customer {request.CustomerId} not found");
        }

        // Verify business exists
        var business = await _context.Businesses
            .FirstOrDefaultAsync(b => b.BusinessId == request.BusinessId, cancellationToken);
        
        if (business == null)
        {
            throw new InvalidOperationException($"Business {request.BusinessId} not found");
        }

        // Check for booking conflicts
        var conflictingBooking = await _context.Bookings
            .Where(b => b.ServiceId == request.ServiceId &&
                       ((request.StartTime < b.EndTime && request.EndTime > b.StartTime) &&
                        b.Status != "Cancelled"))
            .FirstOrDefaultAsync(cancellationToken);

        if (conflictingBooking != null)
        {
            throw new InvalidOperationException("Time slot is not available for this service");
        }

        var booking = new Booking
        {
            BusinessId = request.BusinessId,
            ServiceId = request.ServiceId,
            CustomerId = request.CustomerId,
            StartTime = request.StartTime,
            EndTime = request.EndTime,
            Status = "Confirmed",
            CreatedAt = DateTime.UtcNow
        };

        _context.Bookings.Add(booking);
        await _context.SaveChangesAsync(cancellationToken);

        return MapToDto(booking, business, service, customer);
    }

    /// <summary>
    /// Retrieves a booking by ID
    /// </summary>
    public async Task<BookingDto?> GetBookingByIdAsync(int bookingId, CancellationToken cancellationToken = default)
    {
        var booking = await _context.Bookings
            .Include(b => b.Business)
            .Include(b => b.Service)
            .Include(b => b.Customer)
            .FirstOrDefaultAsync(b => b.BookingId == bookingId, cancellationToken);

        return booking == null ? null : MapToDto(booking, booking.Business!, booking.Service!, booking.Customer!);
    }

    /// <summary>
    /// Retrieves all bookings for a customer
    /// </summary>
    public async Task<IEnumerable<BookingDto>> GetCustomerBookingsAsync(int customerId, CancellationToken cancellationToken = default)
    {
        var bookings = await _context.Bookings
            .Where(b => b.CustomerId == customerId)
            .Include(b => b.Business)
            .Include(b => b.Service)
            .Include(b => b.Customer)
            .OrderByDescending(b => b.CreatedAt)
            .ToListAsync(cancellationToken);

        return bookings.Select(b => MapToDto(b, b.Business!, b.Service!, b.Customer!));
    }

    /// <summary>
    /// Retrieves all bookings for a business
    /// </summary>
    public async Task<IEnumerable<BookingDto>> GetBusinessBookingsAsync(int businessId, CancellationToken cancellationToken = default)
    {
        var bookings = await _context.Bookings
            .Where(b => b.BusinessId == businessId)
            .Include(b => b.Business)
            .Include(b => b.Service)
            .Include(b => b.Customer)
            .OrderByDescending(b => b.StartTime)
            .ToListAsync(cancellationToken);

        return bookings.Select(b => MapToDto(b, b.Business!, b.Service!, b.Customer!));
    }

    /// <summary>
    /// Updates an existing booking
    /// </summary>
    public async Task<BookingDto?> UpdateBookingAsync(int bookingId, UpdateBookingDto request, CancellationToken cancellationToken = default)
    {
        var booking = await _context.Bookings
            .Include(b => b.Business)
            .Include(b => b.Service)
            .Include(b => b.Customer)
            .FirstOrDefaultAsync(b => b.BookingId == bookingId, cancellationToken);

        if (booking == null)
        {
            return null;
        }

        // Validate time range
        if (request.EndTime <= request.StartTime)
        {
            throw new ArgumentException("EndTime must be after StartTime");
        }

        // Check for conflicts with new time slot (excluding this booking)
        var conflictingBooking = await _context.Bookings
            .Where(b => b.BookingId != bookingId &&
                       b.ServiceId == booking.ServiceId &&
                       ((request.StartTime < b.EndTime && request.EndTime > b.StartTime) &&
                        b.Status != "Cancelled"))
            .FirstOrDefaultAsync(cancellationToken);

        if (conflictingBooking != null)
        {
            throw new InvalidOperationException("Time slot is not available for this service");
        }

        booking.StartTime = request.StartTime;
        booking.EndTime = request.EndTime;
        booking.Status = request.Status;

        _context.Bookings.Update(booking);
        await _context.SaveChangesAsync(cancellationToken);

        return MapToDto(booking, booking.Business!, booking.Service!, booking.Customer!);
    }

    /// <summary>
    /// Deletes a booking
    /// </summary>
    public async Task<bool> DeleteBookingAsync(int bookingId, CancellationToken cancellationToken = default)
    {
        var booking = await _context.Bookings
            .FirstOrDefaultAsync(b => b.BookingId == bookingId, cancellationToken);

        if (booking == null)
        {
            return false;
        }

        _context.Bookings.Remove(booking);
        await _context.SaveChangesAsync(cancellationToken);

        return true;
    }

    /// <summary>
    /// Maps a Booking entity to a BookingDto
    /// </summary>
    private static BookingDto MapToDto(Booking booking, Business business, Service service, Customer customer)
    {
        return new BookingDto(
            booking.BookingId,
            booking.BusinessId,
            business.Name,
            booking.ServiceId,
            service.Name,
            booking.CustomerId,
            $"{customer.FirstName} {customer.LastName}",
            booking.StartTime,
            booking.EndTime,
            booking.Status,
            booking.CreatedAt);
    }
}
